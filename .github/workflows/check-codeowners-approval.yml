name: Require CODEOWNERS Approval

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

jobs:
  check-codeowners-approval:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Require CODEOWNER approval if applicable
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });

            const files = await github.paginate(
              github.rest.pulls.listFiles,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.data.number,
              }
            );
            const changedFiles = files.map(f => f.filename);

            const codeownersPath = 'CODEOWNERS';
            if (!fs.existsSync(codeownersPath)) {
              console.log('No CODEOWNERS file found. Skipping check.');
              return;
            }

            const codeownersText = fs.readFileSync(codeownersPath, 'utf8');
            const codeownersRules = codeownersText
              .split('\n')
              .filter(line => line.trim() && !line.trim().startsWith('#'))
              .map(line => {
                const [pattern, ...owners] = line.trim().split(/\s+/);
                return { pattern, owners: owners.map(o => o.replace(/^@/, '')) };
              });

            function matches(pattern, filename) {
              let regexStr = '^';
              let i = 0;
            
              while (i < pattern.length) {
                if (pattern[i] === '*') {
                  if (pattern[i + 1] === '*') {
                    if (pattern[i + 2] === '/') {
                        regexStr += '(?:.*/)?';
                        i += 3;
                    } else {
                        regexStr += '.*';
                        i += 2;
                    }
                  } else {
                      regexStr += '[^/]*';     
                      i += 1;
                  }
                } else {
                    const c = pattern[i];
                    if ('\\.[]{}()+^$|'.includes(c)) {
                      regexStr += '\\' + c;
                    } else {
                      regexStr += c;
                    }
                    i += 1;
                }
              }
              regexStr += '$';
            
              const regex = new RegExp(regexStr);
              return regex.test(filename);
            }


            const requiredOwners = new Set();
            for (const file of changedFiles) {
              for (const rule of codeownersRules) {
                if (matches(rule.pattern,file)) {
                  rule.owners.forEach(owner => requiredOwners.add(owner));
                }
              }
            }

            if (requiredOwners.size === 0) {
              console.log('No CODEOWNERS matched the changed files. Skipping approval check.');
              return;
            }

            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.data.number,
            });

            const approvedBy = new Set(
              reviews.data
                .filter(r => r.state === 'APPROVED')
                .map(r => r.user.login)
            );

            const isApproved = [...requiredOwners].some(owner => approvedBy.has(owner));

            if (!isApproved) {
              core.setFailed(`PR must be approved by at least one matching CODEOWNER: ${[...requiredOwners].join(', ')}`);
            } else {
              console.log('PR approved by a required CODEOWNER. âœ…');
            }
